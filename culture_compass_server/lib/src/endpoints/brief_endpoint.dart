import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:serverpod/serverpod.dart';

import '../generated/protocol.dart';
import '../services/room_event_bus.dart';

class BriefEndpoint extends Endpoint {
  Future<Brief> generateBrief(Session session, int roomId, int userId) async {
    final sources = await Source.db.find(
      session,
      where: (t) => t.roomId.equals(roomId),
    );
    final claims = await Claim.db.find(
      session,
      where: (t) => t.roomId.equals(roomId),
    );
    final contradictions = await Contradiction.db.find(
      session,
      where: (t) => t.roomId.equals(roomId),
    );

    final latest = await Brief.db.findFirstRow(
      session,
      where: (t) => t.roomId.equals(roomId),
      orderBy: (t) => t.version,
      orderDescending: true,
    );
    final nextVersion = (latest?.version ?? 0) + 1;

    final markdown = await _generateWithGroq(
          session,
          sources,
          claims,
          contradictions,
        ) ??
        _buildMarkdown(sources, claims, contradictions);

    final brief = Brief(
      roomId: roomId,
      markdown: markdown,
      version: nextVersion,
      createdBy: userId,
      createdAt: DateTime.now().toUtc(),
    );

    final inserted = await Brief.db.insertRow(session, brief);
    await RoomEventBus.briefUpdated(session, roomId);
    return inserted;
  }

  Future<Brief?> getLatestBrief(Session session, int roomId) async {
    return Brief.db.findFirstRow(
      session,
      where: (t) => t.roomId.equals(roomId),
      orderBy: (t) => t.version,
      orderDescending: true,
    );
  }

  String _buildMarkdown(
    List<Source> sources,
    List<Claim> claims,
    List<Contradiction> contradictions,
  ) {
    final buffer = StringBuffer();
    buffer.writeln('# Morning Brief');
    buffer.writeln();
    buffer.writeln('## Key Takeaways');
    if (claims.isEmpty) {
      buffer.writeln('- No claims captured yet.');
    } else {
      for (final claim in claims.take(5)) {
        buffer.writeln('- ${claim.claimText}');
      }
    }

    buffer.writeln();
    buffer.writeln('## Contradictions to Watch');
    if (contradictions.isEmpty) {
      buffer.writeln('- No contradictions logged yet.');
    } else {
      for (final contradiction in contradictions.take(3)) {
        buffer.writeln(
          '- ${contradiction.disagreementType}: ${contradiction.explanation}',
        );
      }
    }

    buffer.writeln();
    buffer.writeln('## Sources');
    if (sources.isEmpty) {
      buffer.writeln('- No sources added yet.');
    } else {
      for (final source in sources.take(6)) {
        final title = source.title ?? source.url;
        buffer.writeln('- [$title](${source.url})');
      }
    }

    buffer.writeln();
    buffer.writeln('---');
    buffer.writeln('Generated by Culture Compass.');
    return buffer.toString();
  }

  Future<String?> _generateWithGroq(
    Session session,
    List<Source> sources,
    List<Claim> claims,
    List<Contradiction> contradictions,
  ) async {
    final apiKey = session.passwords['groqApiKey'];
    if (apiKey == null || apiKey.isEmpty) return null;

    final uri = Uri.parse('https://api.groq.com/openai/v1/chat/completions');
    final prompt = StringBuffer()
      ..writeln('You are Culture Compass. Write a concise brief in markdown.')
      ..writeln('Include sections: Key Takeaways, Contradictions, Sources.')
      ..writeln('Use source URLs as citations when relevant.')
      ..writeln('')
      ..writeln('Sources:')
      ..writeln(
        sources.map((s) => '- ${s.title ?? s.url} (${s.url})').join('\n'),
      )
      ..writeln('')
      ..writeln('Claims:')
      ..writeln(
        claims.map((c) => '- ${c.claimText}').join('\n'),
      )
      ..writeln('')
      ..writeln('Contradictions:')
      ..writeln(
        contradictions
            .map((c) => '- ${c.disagreementType}: ${c.explanation}')
            .join('\n'),
      );

    try {
      final response = await http
          .post(
            uri,
            headers: {
              'Authorization': 'Bearer $apiKey',
              'Content-Type': 'application/json',
            },
            body: jsonEncode({
              'model': 'llama-3.1-8b-instant',
              'messages': [
                {
                  'role': 'system',
                  'content':
                      'You are a research assistant generating executive briefs.',
                },
                {'role': 'user', 'content': prompt.toString()},
              ],
              'temperature': 0.4,
              'max_tokens': 600,
            }),
          )
          .timeout(const Duration(seconds: 8));
      if (response.statusCode != 200) return null;
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      final choices = payload['choices'] as List<dynamic>? ?? [];
      if (choices.isEmpty) return null;
      final message = choices.first['message'] as Map<String, dynamic>?;
      final content = message?['content'] as String?;
      if (content == null || content.trim().isEmpty) return null;
      return content.trim();
    } catch (_) {
      return null;
    }
  }
}
